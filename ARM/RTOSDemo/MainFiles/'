/*------------------------------------------------------------------------------
 * File:	    	taskLocate.c
 * Authors: 		FreeRTOS, Igor Janjic
 * Description:		Implementation file for locate task. Determines location of
 *                  rover and ramps.
 **---------------------------------------------------------------------------*/

#include "taskLocate.h"

static portTASK_FUNCTION_PROTO(updateTaskLocate, pvParameters);

void startTaskLocate(structLocate* dataLocate, unsigned portBASE_TYPE uxPriority, structLCD* dataLCD, structCommand* dataCommand)
{
    // Create the queue that will be used to talk to this task.
    dataLocate->inQ = xQueueCreate(queueLenLocate, sizeof(msgLocate));
    if(dataLocate->inQ == NULL)
    {
        sendValueMsgLCD(dataLCD, MSG_TYPE_LCD_DEBUG, maxLenLCD, errorQueueCreateLocate, portMAX_DELAY);
        VT_HANDLE_FATAL_ERROR(0);
    }

    // Create the task.
    dataLocate->dataLCD = dataLCD;
    dataLocate->dataCommand = dataCommand;
    
    portBASE_TYPE retval = xTaskCreate(updateTaskLocate, taskNameLocate, LOCATE_STACK_SIZE, (void*)dataLocate, uxPriority, (xTaskHandle*)NULL);
    if(retval != pdPASS)
    {
        sendValueMsgLCD(dataLCD, MSG_TYPE_LCD_DEBUG, maxLenLCD, errorTaskCreateLocate, portMAX_DELAY);
        VT_HANDLE_FATAL_ERROR(retval);
    }
}

void sendTimerMsgLocate(structLocate* dataLocate, portTickType ticksElapsed, portTickType ticksToBlock)
{
    msgLocate msg;
    msg.length = sizeof(ticksElapsed);

    memcpy(msg.buf, &ticksElapsed, msg.length);
    msg.type = MSG_TYPE_TIMER_LOCATE;

    portBASE_TYPE retval = xQueueSend(dataLocate->inQ, (void*)(&msg), ticksToBlock);
    if(retval != pdTRUE)
    {
        sendValueMsgLCD(dataLocate->dataLCD, MSG_TYPE_LCD_DEBUG, maxLenLCD, errorQueueSendLocate, portMAX_DELAY);
        VT_HANDLE_FATAL_ERROR(retval);
    }
}

void sendValueMsgLocate(structLocate* dataLocate, uint8_t type, float* value, portTickType ticksToBlock)
{
    msgLocate msg;
    msg.length = sizeof(float)*bufLenLocate;

    memcpy(msg.buf, value, msg.length);
    msg.type = type;
    portBASE_TYPE retval = xQueueSend(dataLocate->inQ, (void*)(&msg), ticksToBlock);
    if(retval != pdTRUE)
    {
        sendValueMsgLCD(dataLocate->dataLCD, MSG_TYPE_LCD_DEBUG, maxLenLCD, errorQueueSendLocate, portMAX_DELAY);
        VT_HANDLE_FATAL_ERROR(retval);
    }

}

static portTASK_FUNCTION(updateTaskLocate, pvParameters)
{
    // Task parameters.
	structLocate*  param       = (structLocate*)pvParameters;
    structCommand* dataCommand = param->dataCommand;
	structLCD*     dataLCD     = param->dataLCD;
	
	// Buffer for receiving messages.
	msgLocate msg;

    // Allocate space to the map.
    mapSize[0] = MAP_RADIUS_INIT;
    mapSize[1] = MAP_RADIUS_INIT;
    allocateMatrix(map, mapSize[0], mapSize[1]); 

    radix[0] = (MAP_RADIUS_MAX - 1)/2;
    radix[1] = (MAP_RADIUS_MAX - 1)/2;

    // Like all good tasks, this should never exit.
	for(;;)
	{
        // Wait for a message from the queue.
        portBASE_TYPE retQueue = xQueueReceive(param->inQ, (void*)&msg, portMAX_DELAY);
        if (retQueue != pdTRUE)
        {
            sendValueMsgLCD(dataLCD, MSG_TYPE_LCD_DEBUG, maxLenLCD, errorQueueReceiveLocate, portMAX_DELAY);
            VT_HANDLE_FATAL_ERROR(retQueue);
        }

	    // Now, based on the type of the message and the state, do different things.
		switch(msg.type)
		{
		case MSG_TYPE_TIMER_LOCATE:
		{
            switch(curStates.curStatePrimeGoal)
            {
            case scan:
            {
                //execScan(devI2C0);
                break; 
            }
            case roam:
            {
                //execRoam(devI2C0);
                break;
            }
            case go:
            {
                //execGo(devI2C0);
                break;
            }
            case align:
            {
                //execAlign(devI2C0);
                break;
            }
            case ramp:
            {
                //execRamp(devI2C0);               
                break;
            }
			case none:
			{
			   	break;
			}
            default:
            {
                //execDefault();
                break;	
            }
	        }
			break;
        }
        case MSG_TYPE_LOCATE:
        {
            // Update the current rover objects.
			locateObjs(msg.buf);

            bool thresh = getThresh();
            if(thresh)
            {

            }

            break;
        }
        case MSG_TYPE_ACK:
        {
            // Grab the acknowledgement from the motor controller.
            //ack = (bool)msg.buf[0];
            break;
        }
        default:
        {
            // Error...
            break;
        }
        }
    }

}

void allocateMatrix(bool** matrix, uint16_t rows, uint16_t cols)
{
    // Allocates an (rows x cols) size matrix..
    matrix = malloc(sizeof *matrix * rows);
    if(matrix)
    {
        uint16_t i;
        for(i = 0; i < rows; i++)
            matrix[i] = malloc(sizeof *matrix[i] * cols);
    }

    // Initialize matrix to false.
    uint16_t i, j;
    for(i = 0; i < rows; i++)
    {
        for(j = 0; j < cols; j++)
            matrix[i][j] = 0;
    }
}

void freeMatrix(bool** matrix, uint16_t rows)
{
    uint16_t i;
    for(i = 0; i < rows; i++)
    { 
        free(matrix[i]);
    }
    free(matrix);
}

void reallocateMatrix(bool** matrix, uint16_t rows, uint16_t cols, uint8_t direction)
{
    // Allocate a matrix with the new size. 
    bool** newMatrix = 0;

    // Put the values of the old matrix into the new one with shifted positions dependent on the direction parameter.
    switch(direction)
    {
    case 0:
    {
        // Allocated to the right, no need to shift.
        allocateMatrix(newMatrix, rows, 2*cols);

        uint16_t i, j;
        for(i = 0; i < rows; i++)
        {
            for(j = 0; j < cols; j++)
               newMatrix[i][j] = matrix[i][j]; 
        }
        mapSize[0] = rows;
        mapSize[1] = 2*cols;
        break;
    }
    
    case 1:
    {
        // Allocate up so shift down.
        allocateMatrix(newMatrix, 2*rows, cols);

        uint16_t i, j;
        for(i = 0; i < rows; i++)
        {
            for(j = 0; j < cols; j++)
                newMatrix[i + rows][j] = matrix[i][j];
        }
        mapSize[0] = 2*rows;
        mapSize[1] = cols;
        break;
    }
    case 2:
    {
        // Allocate left so shift right.
        allocateMatrix(newMatrix, rows, 2*cols);

        uint16_t i, j;
        for(i = 0; i < rows; i++)
        {
            for(j = 0; j < cols; j++)
                newMatrix[i][j + cols] = matrix[i][j];
        }
        mapSize[0] = rows;
        mapSize[1] = cols;
        break;

    }
    case 3:
    {
        // Allocate down, so no need to shift anything.
        allocateMatrix(newMatrix, 2*rows, cols);

        uint16_t i, j;
        for(i = 0; i < rows; i++)
        {
            for(j = 0; j < cols; j++)
               newMatrix[i][j] = matrix[i][j]; 
        }
        mapSize[0] = 2*rows;
        mapSize[1] = cols;
        break;
    }
    default:
    {
        break;
    }
    }

    // Finish by freeing the old matrix.
    freeMatrix(matrix, rows);
    matrix = newMatrix;
}

void averageMatrix

void locateObjs(float* locateData)
{
    uint8_t curRoverSide = 0;
	const float horizSensorDistance = 2;

	uint8_t i = 0;
    uint8_t notCareSensors = 3; // Last 3 don't affect current close objects.
	for(i = 0; i < SENS_LEN - notCareSensors - 1; i = i + 2)
	{
		float distanceSensor0 = locateData[i];
		float distanceSensor1 = locateData[i + 1];

		// Calculate the distance to the object.
		curObjs[curRoverSide][OBJ_DIST] = (distanceSensor0 + distanceSensor1)/2;

		// Calculate the angle to the object.
		if(distanceSensor0 > distanceSensor1)
			curObjs[curRoverSide][OBJ_ANGLE] =  90 + atan(abs(distanceSensor0 - distanceSensor1)/horizSensorDistance);	
		else
			curObjs[curRoverSide][OBJ_ANGLE] = atan(horizSensorDistance/(abs(distanceSensor0 - distanceSensor1)));

		// Now do the next rover side.
		if(curRoverSide < SIDE_LEN)
                curRoverSide = curRoverSide + 1;
	}

    // Convert to local coordinates.
    curObjs[SIDE_LEFT][OBJ_DIST] = -1*curObjs[SIDE_LEFT][OBJ_DIST];
    curObjs[SIDE_DOWN][OBJ_DIST] = -1*curObjs[SIDE_DOWN][OBJ_DIST];
}
